# -*- coding: utf-8 -*-
"""
Created 2020
@author: Alex Bell

This script applies mode choice models to zone data, including accessibility
and demographic characteristics. The model series utilizes a consistent
structure, analyzing the following modal nests:
    - non-motorized vs motorized
        - (non-motorized) Walk vs. bike
        - (motorized) Auto vs transit
            - (Auto) Driver vs. passenger
            - (Transit) Walk access vs. drive access

These models are applied separately for each travel purpose, and there
are separate models for trip productions and trip attractions. This means
there are 5 models applied to 4 purposes for both trip ends (5*4*2), making
40 model applications in all.

Additionally, models are applied at the block scale in the "window area" and
at the TAZ scale for the rest of the model area.

The application steps rely on two primary types of input:
    - Accessibility scores (generated by mode and purpose) pulled from csv's.
    - Demographic data (HH types) are pulled from the labeled arrays created
      during the trip gen process that contain cross-classified households.

A mode choice labeled array is generated with the following dimensions:
    - Zones (TAZs or blocks depending on the scale of anlysis)
    - HH Size ("-", "HHSize1", "HHSize2", "HHSize3", "HHSize4p")
    - Vehicle Ownership ("-", "Veh0", "Veh1", "Veh2", "Veh3p")
    - Income ("-", "Inc1", "Inc2", "Inc3", "Inc4")
    - Workers ("-", "worker0", "worker1", "worker2", "worker3p")
    - Purpose ("-", "HBW", "HBSch", "HBO", "NHB")
    - End ("P", "A")
    - Mode ("Walk", "Bike", "Drive", "Passenger", "Transit WAT", "Transit DAT")

This means mode shares are estimated by zone, household type ("-" for most
attractions or NHB productions since these are non-home generators), purpose,
and trip end. These shares can then be applied to yet another labeled array:
trips-by-mode, which is the product of the mode choice and trip gen arrays.

Model application entails fetching appropriate sections of the demographic
array (HH by type); vectorizing, reindexing, and broadcasting accessibility
arrays; transforming values based on model coefficients as needed; and
adding model intercept constants.  All of this occurs in an in-memory array
dimensioned to match the targeted section of the on-disk mode choice array.
The accumulated values effectively apply a linear regression formula by adding
coefficient-adjusted factors together. The mode choice models are, however,
binomial logistic equations, and the linear results are used to determine
the probability of selecting each mode in the nest as follows:

    - choice1 = exp(linear_result)/(1 + exp(linear_result))

    - choice0 = 1 - choice1
"""

# %% IMPORTS
import emma
from emma import labeled_array as lba
import numpy as np
import pandas as pd
import os
from wsa import mc

import logging

# All reading/writing taks place within a root directory
#  and analysis is run for a specific scenario.
#  The scenario consists of a combination of land use and network
#  configurations.  Specify which `scen`, `net_config`, and `lu_config`
#  will be analyzed. Resulting accessibility scores will reflect land
#  development in the named `lu_config` and travel costs in the named
#  `net_config`.  Outputs are stored in the `scen` subfolder.
root = r"K:\Projects\MAPC\FInalData"
os.chdir(root)

scen = "BRT_Scen_B"
lu_config = "FEIR"
net_config = "BRT_Scen_B"
base_config = "Base"

# Setup logging
logger = logging.getLogger("EMMA")
logger.setLevel(logging.INFO)
handler = logging.FileHandler(r"scen\{}\log_mode_choice.log".format(scen), mode="w")
handler.setLevel(logging.INFO)
formatter = logging.Formatter('----------------\n%(asctime)s - %(message)s')
handler.setFormatter(formatter)
logger.addHandler(handler)

# %% GLOBALS
PURPOSES = ["HBW", "HBO", "HBSch", "NHB"]
HB_PURPS = ["HBW", "HBO", "HBSch"]
PURPOSE_AXIS = lba.LbAxis("Purpose", PURPOSES)

# For each purpose, accessibility scores focus on different destination types
PURP_ACTIVITIES = {
    "HBW": "Total Emp",
    "HBO": "Retail",
    "HBSch": "TotEnroll",
    "NHB": "Total Emp"
    }

# Modes
MODES = ["walk", "bike", "driver", "passenger", "WAT", "DAT"]
MODE_DICT = {
    "non-motorized": ["walk", "bike"],
    "motorized": ["auto", "transit"],
    "auto": ["driver", "passenger"],
    "transit": ["WAT", "DAT"]
    }

# Analysis scales
SCALES = ["block", "TAZ"]

# Access scores are stored in csv files that are systematically generated.
#  Depending on what geography is needed for indexing, use the appropriate
#  key column, which is recorded in the global variables below.
BLOCK_ACCESS_KEY = "block_id"
TAZ_ACCESS_KEY = "TAZ"
TAZ_LEVEL = "TAZ"

# Models are applied in many cases based on the four household dimensions
#  (size, income, workers, vehicles). Here we set default values corresponding
#  to the labels (categories) in each dimension.
# Assumed persons per HH in each category
HHSIZE = np.array([1, 2, 3, 4.5])
# Income categories (used as factors, hence all 1's)
INCOME = np.array([1, 1, 1, 1])
# Assumed workers per HH in each category
WORKERS = np.array([0, 1, 2, 3.25])
# Assumed vehicles per HH in each category
VEHICLES = np.array([0, 1, 2, 3.25])

#Create dummy axes to ensure HH data are organized properly
HHSIZE_LABELS = ["-", "HHSize1", "HHSize2", "HHSize3", "HHSize4p"]
INCOME_LABELS = ["-", "Income1", "Income2", "Income3", "Income4"]
VEHICLE_LABELS = ["-", "Veh0", "Veh1", "Veh2", "Veh3p"]
WORKER_LABELS = ["-", "worker0", "worker1", "worker2", "worker3p"]
HHSIZE_AXIS = lba.LbAxis("HHSize", HHSIZE_LABELS)
INCOME_AXIS = lba.LbAxis("Income", INCOME_LABELS)
VEHICLE_AXIS = lba.LbAxis("VehOwn", VEHICLE_LABELS)
WORKER_AXIS = lba.LbAxis("Workers", WORKER_LABELS)
PURPOSE_AXIS = lba.LbAxis("Purpose", PURPOSES)
END_AXIS = lba.LbAxis("End", ["P", "A"])
MODE_AXIS = lba.LbAxis("Mode", MODES)

# Create dummy output template.
TEMPLATE_AXES = [HHSIZE_AXIS, INCOME_AXIS, VEHICLE_AXIS, WORKER_AXIS,
                 PURPOSE_AXIS, END_AXIS, MODE_AXIS]
TEMPLATE = lba.Impression(TEMPLATE_AXES)

# It is useful to have the household axis labels handy. In the activity
#  arrays, the value "-" refers to non-home activities. When working on
#  production-end models, we use just the valid home-end activities, so
#  having a handy criteria dictionary keeps things concise.
HH_DICT = {
    "HHSize": ["HHSize1", "HHSize2", "HHSize3", "HHSize4p"],
    "Income": ["Income1", "Income2", "Income3", "Income4"],
    "Workers": ["worker0", "worker1", "worker2", "worker3p"],
    "VehOwn": ["Veh0", "Veh1", "Veh2", "Veh3p"]
    }
NONHOME_DICT = {"HHSize": "-", "Income": "-", "Workers": "-", "VehOwn": "-"}

# Blocks-to-TAZ data frame. This is used to relate TAZs and blocks.
block_list_f = r"input\window_blocks.csv"
BLOCK_LIST_BCOL = "GEOID10"
BLOCK_LIST_TCOL = "TAZ"
BLOCKS_BY_TAZ = pd.read_csv(block_list_f, dtype={BLOCK_LIST_BCOL: str})

# %% CONNECT TO ZONAL TRIP GEN DATA AND CREATE OUTPUT CONTAINERS
# Trip generation data are applied to mode choice estimates to yield trips
#  by mode and purpose. The trip gen results are used to create two output
#  containers that will be updated as the script estimates mode choices.
#   - mode_choice: trip gen data are cast into an additional dimension (Mode)
#      and initialized with a value of 1.0 across all cells. These cells
#      are modified by the mode choice models.
#   - trips_by_mode: trip gen data are cast into the mode dimension with trip
#      gen estimates retained. When the mode choice array is complete, simple
#      multiplication will translate trip gen estimates into trips by mode.
# Separate files are stored for block and TAZ levels.
print("GENERATE OUTPUT CONTAINERS")
# TAZ Trip Gen
ref_file = r"lu\{}\Trips_by_taz.h5".format(lu_config)
ref_node = "/trips"
ref_array = lba.openLbArray_HDF(ref_file, ref_node)

trips_file_z = r"scen\{}\Trips_by_taz.h5".format(scen)
trips_taz_disk = mc.genMCContainers(TEMPLATE, ref_array, "TAZ", trips_file_z,
                                    "/", "trips", mode_axis="Mode",
                                    desc="Trips by mode", copy_data=True)
mc_file_z =  r"scen\{}\Mode_choice_taz.h5".format(scen)
mc_taz_disk = mc.genMCContainers(TEMPLATE, ref_array, "TAZ", mc_file_z,
                                 "/", "mc", mode_axis="Mode",
                                 desc="Mode choice model results",
                                 copy_data=False, init_val=1.0)

# Block Trip Gen
ref_file = r"lu\{}\Trips_by_block.h5".format(lu_config)
ref_node = "/trips"
ref_array = lba.openLbArray_HDF(ref_file, ref_node)

trips_file_b = r"scen\{}\Trips_by_block.h5".format(scen)
trips_block_disk = mc.genMCContainers(TEMPLATE, ref_array, "block_id",
                                      trips_file_b, "/", "trips",
                                      mode_axis="Mode", desc="Trips by mode",
                                      copy_data=True)
mc_file_b =  r"scen\{}\Mode_choice_block.h5".format(scen)
mc_block_disk = mc.genMCContainers(TEMPLATE, ref_array, "block_id", mc_file_b,
                                   "/", "mc", mode_axis="Mode",
                                   desc="Mode choice model results",
                                   copy_data=False, init_val=1.0)

# Keep in-memory working copies for faster performance
mc_taz = mc_taz_disk.copy()
mc_block = mc_block_disk.copy()

#Log
logger.info(
    f"Starting trip sums (broadcast into {len(MODES)} modal dimensions)")
mc.mcInfo(logger, trips_taz_disk, trips_block_disk, mc_taz_disk, mc_block_disk)

# Set scale references - these help automate model application at each
#  scale. They include references to HH array axes, so this function is
#  defined after the array objects are defined.
def getScaleRefs(scale):
    """
    A simple function to set variable references by scale. Simplifies some
    downstream application steps.
    """
    if scale == "TAZ":
        index_cols = [TAZ_ACCESS_KEY]
        suffix = "_TAZ"
        var_axis = mc_taz.TAZ
        var_level = "TAZ"
        dim_name = "TAZ"
        array = mc_taz
        imped_tag = r"-Impedance-BikeTime"
    else:
        index_cols = [BLOCK_ACCESS_KEY]
        suffix = ""
        var_axis = mc_block.block_id
        var_level = "block_id"
        dim_name = "block_id"
        array = mc_block
        imped_tag = ""
    return index_cols, suffix, var_axis, var_level, dim_name, array, imped_tag

# %% LOOKUP WALK ACCESS TO TRANSIT TIMES
# Create a dictionary of walk access to transit time vectors, indexed to
#  match the activity data. The dictionary is accessed by two levels of keys:
#   - "prem"/"non_prem"
#   - "block"/"taz"
# Such that walk_access["prem"]["taz"] returns the vector of taz-level
#  walk access to premium transit times.
# Note that all times are inverted. See function docstring.
print("LOOK UP WALK ACCESS TO TRANSIT TIMES")
prem_base = r"input\skims\{}\walk_to_prem_trans.csv".format(base_config)
non_prem_base = r"input\skims\{}\walk_to_np_trans.csv".format(base_config)
prem_scen = r"input\skims\{}\walk_to_prem_trans.csv".format(net_config)
non_prem_scen = r"input\skims\{}\walk_to_np_trans.csv".format(net_config)
walk_access = mc.loadWalkTimeToTransit(block_taz_df=BLOCKS_BY_TAZ,
                                       block_axis=mc_block.block_id,
                                       taz_axis=mc_taz.TAZ,
                                       prem_base=prem_base, 
                                       non_prem_base=non_prem_base,
                                       prem_scen=prem_scen,
                                       non_prem_scen=non_prem_scen,
                                       block_level="block_id",
                                       taz_level="TAZ",
                                       block_id_field="BLOCKID",
                                       time_field="Total_Minutes",
                                       df_block_col=BLOCK_LIST_BCOL,
                                       df_taz_col=BLOCK_LIST_TCOL)

# %% PARKING CHARGES
#  Pulled from the land use configuration
print("LOOK UP PARKING CHARGES")
taz_f = r"input\zones\{}\MAPC_TAZ_data.xlsx".format(lu_config)
sheet = "Terminal Time Parking Cost"
id_field = "TAZ_ID"
parking_col = "Parking_cost"
pc = pd.read_excel(taz_f, sheet)
pc = pc[[id_field, parking_col]].set_index(id_field)
PC_TAZ = pc.reindex(mc_taz.TAZ.labels, fill_value = 0.0, copy=False)
PC_BLOCK = mc.inheritAccessScore(PC_TAZ, mc_block.block_id)

# %% HOME-BASED: NON-MOTORIZED VS. MOTORIZED 
# Variables:
#  - Bike-auto access ratio (ln(bike_scores + 1)/ln(auto_scores + 1))
#      - Bike access to jobs
#      - Auto access to jobs
#  - HH vehicles
#  - HH Workers (HBW only)
print("Non-motorized / motorized (home-based)")
end = "P"
this_mode = "non-motorized"
complement = "motorized"
logger.info(
    f"Estimated mode: {this_mode}\n\tComplement mode: {complement}\n\tEnd: {end}")

coef_dict = {
    "HBW": {
        "Intercept": -5.8033,
        "BAR": 6.1417,
        "VehOwn": -0.7569,
        "JHBike": -0.9347
        },
    "HBO": {
        "Intercept": -4.1374,
        "BAR": 4.0566,
        "VehOwn": -0.5901
        },
    "HBSch": { 
        "Intercept": -1.0878,
        "BAR": 0.8277,
        "VehOwn": -0.5365
        }
    }

for p in HB_PURPS:
    logger.info(f"-- Purpose: {p}")
    # Get the accessibility scores that correspond to each purpose
    activity = PURP_ACTIVITIES[p]
    
    for scale in SCALES:
        logger.info(f"-- -- Scale: {scale}")
        refs = getScaleRefs(scale)
        index_cols, suffix, var_axis, var_level, dim_name,\
            array, imped_tag = refs

        # Get the bike scores
        bike_scores = mc.fetchAccessScores(scen, "bike", p, "to", activity,
                                           index_cols, suffix=suffix,
                                           match_axis=var_axis,
                                           match_level=var_level,
                                           imped_tag=imped_tag)
        # Get the auto scores
        auto_scores = mc.fetchAccessScores(scen, "auto", p, "to", activity,
                                           [TAZ_ACCESS_KEY], match_level=TAZ_LEVEL,
                                           match_axis=mc_taz.TAZ)
        # All HHs
        bike_hh = mc.fetchAccessScores(scen, "bike", p, "from", "TotalHH",
                                       index_cols, suffix=suffix,
                                       match_axis=var_axis,
                                       match_level=var_level,
                                       imped_tag=imped_tag)
        bike_hh.columns = [activity]
        
        # jh_mix
        bike_hh.columns = [activity]
        jh_bike = bike_scores/(bike_scores + bike_hh)
        jh_bike.fillna(0.0, inplace=True)
        jh_bike.replace(np.inf, 0.0, inplace=True)

        # Push auto scores to block level
        if scale == "block":
            auto_scores = mc.inheritAccessScore(auto_scores, mc_block.block_id)

        # Calculate BAR
        auto_scores = np.log(auto_scores + 1)
        bike_scores = np.log(bike_scores + 1)
        bar = bike_scores/auto_scores
        bar.clip(0, 1.0, inplace=True)
        
        # Log inputs
        logger.info("  -- -- -- |Input BAR - quartiles: {}".format(
            np.quantile(bar[activity].fillna(0.0), np.linspace(0, 1, 5))))
        logger.info("  -- -- -- |Input JH-bike - quartiles: {}".format(
            np.quantile(jh_bike[activity].fillna(0.0), np.linspace(0, 1, 5))))
        
        # Create the model dictionary
        model_dict = {
            dim_name: {
                "values": [
                    bar[activity].fillna(0.0),
                    jh_bike[activity]
                    ],
                "coef": [
                    coef_dict[p].get("BAR", 0.0),
                    coef_dict[p].get("JHBike", 0.0)
                    ]
                },
            "VehOwn": {
                "values": VEHICLES,
                "coef": coef_dict[p].get("VehOwn", 0.0)
                },
            "Workers": {
                "values": WORKERS,
                "coef": coef_dict[p].get("Workers", 0.0)
                }
            }
        intercept = coef_dict[p].get("Intercept", 0.0)
        crit = {"Purpose": p, "End": end, "Mode": "walk"}
        crit.update(HH_DICT)
        mc.modeChoiceApply(array, intercept, model_dict, this_mode,
                           complement, MODE_DICT, crit, logger=logger)

# %% HOME-BASED: AUTO VS. TRANSIT
# Variables:
#  - Transit () - auto () access ratio
#     (HBW [max], HBO [WAT], HBSch [max])
#      - Transit access to jobs (*max = Get max value from among all
#         transit submodes (WAT, DAT*) [log]
#      - Auto access to jobs
#  - HH vehicles
#  - HH Workers (HBW only)
#  - Income
#     - Factor: seperate coefficients for each category
#  - Distance to premium transit
print("Auto / transit (home-based)")
end = "P"
this_mode = "auto"
complement = "transit"
logger.info(
    f"Estimated mode: {this_mode}\n\tComplement mode: {complement}\n\tEnd: {end}")

coef_dict = {
    "HBW": {
         "Intercept": 3.0311,
         "TranAccess": -2.5469,
         "VehOwn": 1.0132,
         "Workers": -0.2239,
         "Income": [0.0, -0.0406, -0.4988, -0.6818],
         "Prem": -3.5918,
        },
    "HBO": {
        "Intercept": 1.07627,
        "TranAccess": -0.777461,
        "VehOwn": 2.12264,
        "Income": [0.0, 0.6364, 0.5435, 0.4381],
        "Prem": -1.74419
        },
    "HBSch": {
        "Intercept": 1.8053,
        "TranAccess": -1.9245,
        "VehOwn": 0.9186,
        "Income": [0.0, 0.5459, 0.8938, 1.1320],
        "Prem": -4.3172,
        }
    }

for p in HB_PURPS:
    logger.info(f"-- Purpose: {p}")
    # Get the accessibility scores that correspond to each purpose
    activity = PURP_ACTIVITIES[p]
    
    for scale in SCALES:
        logger.info(f"-- -- Scale: {scale}")
        refs = getScaleRefs(scale)
        index_cols, suffix, var_axis, var_level, dim_name,\
            array, imped_tag = refs
    
        # Get the transit scores
        wat_scores = mc.fetchAccessScores(scen, "transit", p, "to", activity,
                                          [TAZ_ACCESS_KEY], match_level=TAZ_LEVEL,
                                          match_axis=mc_taz.TAZ)
        # Get the auto scores
        auto_scores = mc.fetchAccessScores(scen, "auto", p, "to", activity,
                                           [TAZ_ACCESS_KEY], match_level=TAZ_LEVEL,
                                           match_axis=mc_taz.TAZ)
        # Calcualte TAR
        if p == "HBO":
            tran_access = wat_scores/auto_scores
        else:
            tran_access = np.log(wat_scores + 1)/np.log(auto_scores + 1)
            
        # Push TAR to block level
        if scale == "block":
            tran_access = mc.inheritAccessScore(tran_access, mc_block.block_id)
        
        # Get walk access to transit
        prem = walk_access["prem"][scale.lower()]
        
        # Log inputs
        logger.info("  -- -- -- |Input TransitAccess - quartiles: {}".format(
            np.quantile(tran_access.fillna(0.0), np.linspace(0, 1, 5))))
        logger.info("  -- -- -- |Input Prem Transit - quartiles: {}".format(
            np.quantile(prem, np.linspace(0, 1, 5))))
        
        # Create the model dictionary
        model_dict = {
           dim_name: {
                "values": [
                    tran_access.fillna(0.0),
                    prem,
                    ],
                "coef": [
                    coef_dict[p].get("TranAccess", 0.0),
                    coef_dict[p].get("Prem", 0.0),
                    ]
                },
            "VehOwn": {
                "values": VEHICLES,
                "coef": coef_dict[p].get("VehOwn", 0.0)
                },
            "Workers": {
                "values": WORKERS,
                "coef": coef_dict[p].get("Workers", 0.0)
                },
            "Income": {
                "values": INCOME,
                "coef": coef_dict[p].get("Income", 0.0)
                },
            }
        intercept = coef_dict[p].get("Intercept", 0.0)
        crit = {"Purpose": p, "End": end, "Mode": "walk"}
        crit.update(HH_DICT)
        mc.modeChoiceApply(array, intercept, model_dict, this_mode,
                           complement, MODE_DICT, crit, logger=logger)

# %% HOME-BASED: AUTO DRIVER VS. AUTO PASSENGER
# Variables:
#  - Vehicles per person
#      - HH vehicles
#      - HH Size
#  - HH Size
#  - HH Workers (HBW only)
#  - Income
#     - Factor: seperate coefficients for each category
print("Driver / passenger (home-based)")
end = "P"
this_mode = "driver"
complement = "passenger"
logger.info(
    f"Estimated mode: {this_mode}\n\tComplement mode: {complement}\n\tEnd: {end}")

coef_dict = {
    "HBW": {
        "Intercept": -0.35084,
        "VPP": 3.64719,
        "Size": 0.53747,
        "Workers": -0.90945,
        "Income": [0.0, 0.6845, 0.9729, 1.0697]
        },
    "HBO": {
        "Intercept": 0.27892,
        "VPP": 1.66631,
        "Size": -0.18135,
        "Income": [0.0, 0.1262, 0.1638, 0.1950]
        },
    "HBSch": {
        "Intercept": -4.4997,
        "VPP": 4.5287
        }
    }

for p in HB_PURPS:
    logger.info(f"-- Purpose: {p}")
    # Get the accessibility scores that correspond to each purpose
    activity = PURP_ACTIVITIES[p]
    
    for scale in SCALES:
        logger.info(f"-- -- Scale: {scale}")
        refs = getScaleRefs(scale)
        index_cols, suffix, var_axis, var_level, dim_name,\
            array, imped_tag = refs
        
        # Cast vehicles per person
        vpp = np.divide(*np.meshgrid(VEHICLES, HHSIZE))
        hh_axis = lba.LbAxis("HHSize", HHSIZE_LABELS[1:])
        veh_axis = lba.LbAxis("VehOwn", VEHICLE_LABELS[1:])
        work_axis = lba.LbAxis("Workers", WORKER_LABELS[1:])
        inc_axis = lba.LbAxis("Income", INCOME_LABELS[1:])
        vpp_array = lba.LbArray(vpp, [hh_axis, veh_axis])
        vpp_expand = vpp_array.cast([var_axis, work_axis, inc_axis])
        vpp_expand = lba.alignAxes(
            vpp_expand, array.impress(drop=["Mode", "Purpose", "End"]))
        
        # Log inputs
        logger.info("  -- -- -- |Input Vehicles Per person - quartiles: {}".format(
            np.quantile(vpp, np.linspace(0, 1, 5))))
        
        # Create the model dictionary
        model_dict = {
           "HHSize": {
                "values": HHSIZE,
                "coef": 
                    coef_dict[p].get("Size", 0.0)
                },
            "VehOwn": {
                "values": vpp_expand,
                "coef": coef_dict[p].get("VPP", 0.0)
                },
            "Workers": {
                "values": WORKERS,
                "coef": coef_dict[p].get("Workers", 0.0)
                },
            "Income": {
                "values": INCOME,
                "coef": coef_dict[p].get("Income", 0.0)
                },
            }
        intercept = coef_dict[p].get("Intercept", 0.0)
        crit = {"Purpose": p, "End": end, "Mode": "walk"}
        crit.update(HH_DICT)
        mc.modeChoiceApply(array, intercept, model_dict, this_mode,
                           complement, MODE_DICT, crit, logger=logger)

# %% HOME-BASED: WAT VS. DAT
# Variables:
#  - WAT:DAT access ratio
#      - WAT access to jobs
#      - Max DAT access to jobs
#  - Walk time to transit (HBW [prem], HBO [nonprem], HBSch [prem])
#  - HH Workers (HBW only)
#  - Income
#     - Factor: seperate coefficients for each category
print("WAT / DAT (home-based)")
end = "P"
this_mode = "WAT"
complement = "DAT"
logger.info(
    f"Estimated mode: {this_mode}\n\tComplement mode: {complement}\n\tEnd: {end}")

coef_dict = {
    "HBW": {
        "Intercept": 1.2376,
        "WDR": 1.4113,
        "WalkTime": 3.1342,
        "Vehicles": -1.0369,
        "Workers": 0.4427,
        "Income": [0.0, -0.6484, -0.9407, -1.0538]
        },
    "HBO": {
        "Intercept": 1.7423,
        "WDR": 1.7120,
        "WalkTime": 1.8392,
        "Vehicles": -1.1170
        },
    "HBSch": {
        "Intercept": 1.9315,
        "WDR": 0.9027,
        "Vehicles": -0.9790,
        "HHSize": 0.1944
        }
    }

for p in HB_PURPS:
    logger.info(f"-- Purpose: {p}")
    # Get the accessibility scores that correspond to each purpose
    activity = PURP_ACTIVITIES[p]
    
    for scale in SCALES:
        logger.info(f"-- -- Scale: {scale}")
        refs = getScaleRefs(scale)
        index_cols, suffix, var_axis, var_level, dim_name,\
            array, imped_tag = refs
        
        # WDR
        wat_scores = mc.fetchAccessScores(scen, "transit", p, "to", activity,
                                          [TAZ_ACCESS_KEY], match_level=TAZ_LEVEL,
                                          match_axis=mc_taz.TAZ)
        max_scores = mc.fetchAccessScores(scen, "transit_da", p, "to",
                                          activity, [TAZ_ACCESS_KEY],
                                          match_axis=mc_taz.TAZ, match_level=TAZ_LEVEL)
        max_scores.replace(0.0, 1.0, inplace=True)
        wdr = wat_scores/max_scores
        wdr.clip(0, 100, inplace=True)
        
        # Push WDR to block level
        if scale == "block":
            wdr = mc.inheritAccessScore(wdr, mc_block.block_id)
        
        # Walk Times
        if p == "HBO":
            walk_times = walk_access["non_prem"][scale.lower()]
        else:
            walk_times = walk_access["prem"][scale.lower()]
        
        # Log inputs
        logger.info("  -- -- -- |Input Walk-Drive Trans Ratio - quartiles: {}".format(
            np.quantile(wdr[activity].fillna(0.0), np.linspace(0, 1, 5))))
        logger.info("  -- -- -- |Input Walk Time to Transit - quartiles: {}".format(
            np.quantile(walk_times, np.linspace(0, 1, 5))))
        
        # Create the model dictionary
        model_dict = {
            dim_name: {
                "values": [
                    wdr[activity].fillna(0.0), 
                    walk_times
                    ],
                "coef": [
                    coef_dict[p].get("WDR", 0.0),
                    coef_dict[p].get("WalkTime", 0.0)
                    ]
                },
            "VehOwn": {
                "values": VEHICLES,
                "coef": coef_dict[p].get("VPP", 0.0)
                },
            "Workers": {
                "values": WORKERS,
                "coef": coef_dict[p].get("Workers", 0.0)
                },
            "Income": {
                "values": INCOME,
                "coef": coef_dict[p].get("Income", 0.0)
                },
            "HHSize": {
                "values": HHSIZE,
                "coef": coef_dict[p].get("HHSize", 0.0)
                }
            }
        intercept = coef_dict[p].get("Intercept", 0.0)
        crit = {"Purpose": p, "End": end, "Mode": "walk"}
        crit.update(HH_DICT)
        mc.modeChoiceApply(array, intercept, model_dict, this_mode,
                           complement, MODE_DICT, crit, logger=logger)

# %% HOME-BASED: WALK VS. BIKE
# Variables:
#  - Walk/bike access ratio
#     - Walk access to jobs
#     - Bike access to jobs
#  - Income
#     - Factor: separate coefficients for each category
print("Walk / Bike (home-based)")
end = "P"
this_mode = "walk"
complement = "bike"
logger.info(
    f"Estimated mode: {this_mode}\n\tComplement mode: {complement}\n\tEnd: {end}")

coef_dict = {
    "HBW": {
        "Intercept": 1.6719,
        "WBR": 2.1060,
        "Income": [0.0, -1.1485, -1.5740, -1.5044]
        },
    "HBO": {
        "Intercept": 2.0372,
        "WBR": 2.5636,
        "Income": [0.0, -0.4282, -0.4411, -0.4556]
        },
    "HBSch": {
        "Intercept": 2.3185,
        "WBR": 3.0834,
        "Income": [0.0, -0.4354, -0.8176, -0.5509]
        }
    }

for p in HB_PURPS:
    logger.info(f"-- Purpose: {p}")
    # Get the accessibility scores that correspond to each purpose
    activity = PURP_ACTIVITIES[p]
    
    for scale in SCALES:
        logger.info(f"-- -- Scale: {scale}")
        refs = getScaleRefs(scale)
        index_cols, suffix, var_axis, var_level, dim_name,\
            array, imped_tag = refs
        if imped_tag:
            imped_tag_w = imped_tag.replace("Bike", "Walk")
        else:
            imped_tag_w = ""
        
        # Walk scores
        walk_scores = mc.fetchAccessScores(scen, "walk", p, "to", activity,
                                           index_cols, suffix=suffix,
                                           match_axis=var_axis,
                                           match_level=var_level,
                                           imped_tag=imped_tag_w)
        # Bike scores
        bike_scores = mc.fetchAccessScores(scen, "bike", p, "to", activity,
                                           index_cols, suffix=suffix,
                                           match_axis=var_axis,
                                           match_level=var_level,
                                           imped_tag=imped_tag)
        bike_scores.replace(0.0, 1.0, inplace=True)
        
        # WBR
        wbr = walk_scores/bike_scores
        wbr.clip(0, 1.0, inplace=True)
        
        # Log inputs
        logger.info("  -- -- -- |Input Walk-Bike ratio - quartiles: {}".format(
            np.quantile(wbr[activity].fillna(0.0), np.linspace(0, 1, 5))))
        
        # Create the model dictionary
        model_dict = {
            dim_name: {
                "values": wbr[activity].fillna(0.0),
                "coef": coef_dict[p].get("WBR", 0.0)
                },
            "Income": {
                "values": INCOME,
                "coef": coef_dict[p].get("Income", 0.0)
                },
            }
        intercept = coef_dict[p].get("Intercept", 0.0)
        crit = {"Purpose": p, "End": end, "Mode": "walk"}
        crit.update(HH_DICT)
        mc.modeChoiceApply(array, intercept, model_dict, this_mode,
                           complement, MODE_DICT, crit, logger=logger)

# %% ATTRACTIONS: NON-MOTORIZED VS. MOTORIZED 
# Variables:
#  - Bike-auto access ratio 
#      - Bike access to jobs
#      - Auto access to jobs 
#  - Share of zero-vehicle households in bike access shed
#      - Bike access from zero-vehicle HHs
#      - Bike access from all HHs
#  - Jobs access share of total bike access shed activities
#      - Bike access to jobs/(Bike acecss to jobs + Bike access from HHs)
#  - Walk time to transit (prem for all purposes except NHB)
#  - Parking charges
print("Nonmotorized / motorized (attractions)")
end = "A"
this_mode = "non-motorized"
complement = "motorized"
logger.info(
    f"Estimated mode: {this_mode}\n\tComplement mode: {complement}\n\tEnd: {end}")

coef_dict = {
    "HBW": {
        "Intercept": -3.295599,
        "BAR": 6.038310,
        "Veh0": 2.904955,
        "JHMix": -1.279283,
        "WalkTime": -1.455904,
        "Parking": -0.065385
        },
    "HBO": {
        "Intercept": -2.828600,
        "BAR": 4.225139,
        "Veh0": 2.583888,
        "JHMix": -2.679922,
        "WalkTime": -0.461462,
        "Parking": -0.055689
        },
    "HBSch": {
        "Intercept": -3.20179,
        "BAR": 1.0028,
        "Veh0": 7.17876,
        "WalkTime": -1.89655,
        "Parking": -0.05897
        },
    "NHB": {
        "Intercept": -3.150525,
        "BAR": 10.343651,
        "WalkTime": 0.344886,
        "Parking": -0.042528
        }
    }

for p in PURPOSES:
    logger.info(f"-- Purpose: {p}")
    # Get the accessibility scores that correspond to each purpose
    activity = PURP_ACTIVITIES[p]
    
    for scale in SCALES:
        #print("-- --", scale)
        logger.info(f"-- -- Scale: {scale}")
        refs = getScaleRefs(scale)
        index_cols, suffix, var_axis, var_level, dim_name,\
            array, imped_tag = refs
        
        # Get the bike scores
        bike_scores = mc.fetchAccessScores(scen, "bike", p, "to", activity,
                                           index_cols, suffix=suffix,
                                           match_axis=var_axis,
                                           match_level=var_level,
                                           imped_tag=imped_tag)
        # Get the auto scores
        auto_scores = mc.fetchAccessScores(scen, "auto", p, "to", activity,
                                           [TAZ_ACCESS_KEY], match_level=TAZ_LEVEL,
                                           match_axis=mc_taz.TAZ)
        # Push auto scores to block level
        if scale == "block":
            auto_scores = mc.inheritAccessScore(auto_scores, mc_block.block_id)
            parking = PC_BLOCK
        else:
            parking = PC_TAZ
        # Calculate BAR
        bar = bike_scores/auto_scores
        bar.clip(0, 1.0, inplace=True)
        
        # Zero vehicle HHs
        bike_0veh = mc.fetchAccessScores(scen, "bike", p, "from", "Veh0",
                                         index_cols, suffix=suffix,
                                         match_axis=var_axis,
                                         match_level=var_level,
                                         imped_tag=imped_tag)
        # All HHs
        bike_hh = mc.fetchAccessScores(scen, "bike", p, "from", "TotalHH",
                                       index_cols, suffix=suffix,
                                       match_axis=var_axis,
                                       match_level=var_level,
                                       imped_tag=imped_tag)
        bike_hh.columns = ["Veh0"]
        
        # share with no cars
        share_0veh = bike_0veh/bike_hh
        share_0veh.fillna(0.0, inplace=True)
        share_0veh.replace(np.inf, 0.0, inplace=True)
        
        # jh_mix
        bike_hh.columns = [activity]
        jh_bike = bike_scores/(bike_scores + bike_hh)
        jh_bike.fillna(0.0, inplace=True)
        jh_bike.replace(np.inf, 0.0, inplace=True)
        
        # walk time
        if p == "NHB":
            walk_times = walk_access["non_prem"][scale.lower()]
        else:
            walk_times = walk_access["prem"][scale.lower()]

        # Create the model dictionary
        model_dict = {
            dim_name: {
                "values": [
                    bar[activity],
                    share_0veh,
                    jh_bike,
                    walk_times,
                    parking
                    ],
                "coef": [
                    coef_dict[p].get("BAR", 0.0),
                    coef_dict[p].get("Veh0", 0.0),
                    coef_dict[p].get("JHMix", 0.0),
                    coef_dict[p].get("WalkTime", 0.0),
                    coef_dict[p].get("Parking", 0.0)
                    ]
                }
            }
        intercept = coef_dict[p].get("Intercept", 0.0)
        crit = {"Purpose": p, "End": end, "Mode": "walk"}
        mc.modeChoiceApply(array, intercept, model_dict, this_mode,
                           complement, MODE_DICT, crit, logger=logger)

# %% ATTRACTIONS: AUTO VS. TRANSIT
# Variables:
#  - Transit[walk access]- auto access ratio
#     (corresponds to purpose except HBSch, which uses the HBW formulation)
#      - WAT access to jobs
#      - Auto access to jobs
#  - Walk access - auto access ratio (HB School only)
#      - Walk access to jobs
#      - Auto access to jobs
#  - Jobs access share of total transit access shed activities
#      - Transit access to jobs/(Transit acecss to jobs + Transit access from HHs)
#      - Use best-available transit scores
#  - Transit access (WAT) to low income households
#  - Walk time to transit
#      - Premium
#      - Non-premium
#  - Parking charges
print("Auto / transit (attractions)")
end = "A"
this_mode = "auto"
complement = "transit"
logger.info(
    f"Estimated mode: {this_mode}\n\tComplement mode: {complement}\n\tEnd: {end}")

coef_dict = {
    "HBW": {
        "Intercept": 3.783,
        "TAR": -0.8269,
        "JHMix": -0.5101,
        "LowIncHHs": -1.961e-05,
        "Prem": -2.937,
        "Nonprem": -1.499,
        "Parking": -8.052e-03
        },
    "HBO": {
        "Intercept": 3.788,
        "TAR": -0.1953,
        "JHMix": 1.239,
        "LowIncHHs": -2.765e-05,
        "Prem": -1.417,
        "Nonprem": -1.403,
        "Parking": -7.096e-03
        },
    "HBSch": {
        "Intercept": 2.987,
        "TAR": -0.8283, # Use access to jobs, not enrollments
        "WAR": -3.684,
        "JHMix": 1.371,
        "LowIncHHs": -1.180e-05,
        "Prem": -3.101,
        "Nonprem": -1.903
        },
    "NHB": {
        "Intercept": 4.45978,
        "TAR": -1.61354,
        "Prem": -2.38107,
        "Nonprem": -0.56405
        }
    }

for p in PURPOSES:
    logger.info(f"-- Purpose: {p}")
    # Get the accessibility scores that correspond to each purpose
    activity = PURP_ACTIVITIES[p]
    for scale in SCALES:
        logger.info(f"-- -- Scale: {scale}")
        refs = getScaleRefs(scale)
        index_cols, suffix, var_axis, var_level, dim_name,\
            array, imped_tag = refs
        if imped_tag:
            imped_tag_w = imped_tag.replace("Bike", "Walk")
        else:
            imped_tag_w = ""
        
        # Get the transit scores
        transit_scores = mc.fetchAccessScores(scen, "transit", p, "to",
                                              activity, [TAZ_ACCESS_KEY],
                                              match_axis=mc_taz.TAZ, match_level=TAZ_LEVEL)
        # T -- all jobs regardless of activity
        transit_jobs = mc.fetchAccessScores(scen, "transit", "HBW", "to",
                                            "Total Emp", [TAZ_ACCESS_KEY],
                                            match_axis=mc_taz.TAZ, match_level=TAZ_LEVEL)
        # T -- All HHs
        tran_hh = mc.fetchAccessScores(scen, "transit", p, "from", "TotalHH",
                                      [TAZ_ACCESS_KEY], match_axis=mc_taz.TAZ, match_level=TAZ_LEVEL)
        # T -- Low income HHs
        tran_Inc1 = mc.fetchAccessScores(scen, "transit", p, "from", "Income1",
                                        [TAZ_ACCESS_KEY], match_level=TAZ_LEVEL,
                                        match_axis=mc_taz.TAZ)
        # Get the auto scores
        auto_scores = mc.fetchAccessScores(scen, "auto", p, "to", activity,
                                          [TAZ_ACCESS_KEY], match_level=TAZ_LEVEL,
                                          match_axis=mc_taz.TAZ)            
        # A -- all jobs regardless of activity
        auto_jobs = mc.fetchAccessScores(scen, "auto", "HBW", "to",
                                         "Total Emp", [TAZ_ACCESS_KEY],
                                         match_axis=mc_taz.TAZ, match_level=TAZ_LEVEL)
        # Get the walk scores
        walk_scores = mc.fetchAccessScores(scen, "walk", p, "to", activity,
                                           index_cols, suffix=suffix,
                                           match_axis=var_axis,
                                           match_level=var_level,
                                           imped_tag=imped_tag_w)
        # Push scores to block level
        if scale == "block":
            auto_scores = mc.inheritAccessScore(auto_scores, mc_block.block_id)
            auto_jobs = mc.inheritAccessScore(auto_jobs, mc_block.block_id)
            transit_scores = mc.inheritAccessScore(transit_scores, mc_block.block_id)
            transit_jobs = mc.inheritAccessScore(transit_jobs, mc_block.block_id)
            tran_hh = mc.inheritAccessScore(tran_hh, mc_block.block_id)
            tran_Inc1 = mc.inheritAccessScore(tran_Inc1, mc_block.block_id)
            parking = PC_BLOCK
        else:
            parking = PC_TAZ

        # Calculate TAR
        if p == "HBSch":
            tar = transit_jobs/auto_jobs
        else:
            tar = transit_scores/auto_scores
        
        tar.fillna(0.0, inplace=True)
        tar.replace(np.inf, 0.0, inplace=True)
        
        # Calculate the WAR
        war = walk_scores/auto_scores
        war.fillna(0.0, inplace=True)
        war.replace(np.inf, 0.0, inplace=True)

        # jh_mix
        tran_hh.columns = [activity]
        jh_tran = transit_scores/(transit_scores + tran_hh)
        jh_tran.fillna(0.0, inplace=True)
        jh_tran.replace(np.inf, 0.0, inplace=True)
        
        # walk time
        nonprem =  walk_access["non_prem"][scale.lower()]
        prem = walk_times = walk_access["prem"][scale.lower()]

        # Create the model dictionary
        model_dict = {
            dim_name: {
                "values": [
                    tar,
                    war,
                    jh_tran,
                    tran_Inc1,
                    prem,
                    nonprem,
                    parking
                    ],
                "coef": [
                    coef_dict[p].get("TAR", 0.0),
                    coef_dict[p].get("WAR", 0.0),
                    coef_dict[p].get("JHMix", 0.0),
                    coef_dict[p].get("LowIncHHs", 0.0),
                    coef_dict[p].get("Prem", 0.0),
                    coef_dict[p].get("Nonprem", 0.0),
                    coef_dict[p].get("Parking", 0.0)
                    ]
                }
            }
        intercept = coef_dict[p].get("Intercept", 0.0)
        crit = {"Purpose": p, "End": end, "Mode": "walk"}
        mc.modeChoiceApply(array, intercept, model_dict, this_mode,
                           complement, MODE_DICT, crit, logger=logger)

# %% ATTRACTIONS: DRIVER VS. PASSENGER
# Variables:
#  - Walk access - auto access ratio 
#      - Walk access to jobs
#      - Auto access to jobs
#  - Average vehicles among households with auto access to each zone
#  - Share of accessible households that are in highest income ranges
#  - Walk time to transit
#      - Non-premium
print("Driver / passenger (attractions)")
end = "A"
this_mode = "driver"
complement = "passenger"
logger.info(
    f"Estimated mode: {this_mode}\n\tComplement mode: {complement}\n\tEnd: {end}")

coef_dict = {
    "HBW": {
        "Intercept": -1.3457,
        "AvgHHVeh": 2.3187,
        "HighIncHHs": 3.2010,
        "WAR": -1.7314,
        "Nonprem": -0.5303
        },
    "HBO": {
        "Intercept": 0.59366,
        "AvgHHVeh": 0.21919
        },
    "HBSch": {
        "Intercept": -3.4836,
        "AvgHHVeh": 1.2388
        },
    "NHB": {
        "Intercept": 1.20332 #This is an intercept-only model
        }
    }

for p in PURPOSES:
    logger.info(f"-- Purpose: {p}")
    # Get the accessibility scores that correspond to each purpose
    activity = PURP_ACTIVITIES[p]
    
    for scale in SCALES:
        logger.info(f"-- -- Scale: {scale}")
        refs = getScaleRefs(scale)
        index_cols, suffix, var_axis, var_level, dim_name,\
            array, imped_tag = refs
        if imped_tag:
            imped_tag_w = imped_tag.replace("Bike", "Walk")
        else:
            imped_tag_w = ""
        
        # Get total accessible HHs
        auto_hh = mc.fetchAccessScores(scen, "auto", p, "from", "TotalHH",
                                       [TAZ_ACCESS_KEY], match_level=TAZ_LEVEL,
                                       match_axis=mc_taz.TAZ)
        # Get high income HHs
        auto_Inc4 = mc.fetchAccessScores(scen, "auto", p, "from", "Income4",
                                        [TAZ_ACCESS_KEY], match_level=TAZ_LEVEL,
                                        match_axis=mc_taz.TAZ)
        auto_Inc4.columns = ["TotalHH"]
        # Get share high income
        share_Inc4 = auto_Inc4/auto_hh
        # Get accessible HHs by veh ownership
        #  (zero car HHs not needed since they have no vehicles)
        auto_1veh = mc.fetchAccessScores(scen, "auto", p, "from", "Veh1",
                                        [TAZ_ACCESS_KEY], match_level=TAZ_LEVEL,
                                        match_axis=mc_taz.TAZ)
        auto_1veh.columns = ["TotalHH"]
        auto_2veh = mc.fetchAccessScores(scen, "auto", p, "from", "Veh2",
                                        [TAZ_ACCESS_KEY], match_level=TAZ_LEVEL,
                                        match_axis=mc_taz.TAZ)
        auto_2veh.columns = ["TotalHH"]
        auto_3veh = mc.fetchAccessScores(scen, "auto", p, "from", "Veh3p",
                                        [TAZ_ACCESS_KEY], match_level=TAZ_LEVEL,
                                        match_axis=mc_taz.TAZ)
        auto_3veh.columns = ["TotalHH"]
        
        # Weight HH vehicle data 
        #  Multiply 2-vehicle HHs by 2.0 and 3+ vehicle HHs by 3.25
        auto_2veh *= VEHICLES[-2]
        auto_3veh *= VEHICLES[-1]
        
        # Summarize average vehicle ownership
        weighted_veh = auto_1veh + auto_2veh + auto_3veh
        avg_hh_veh = weighted_veh/auto_hh
        avg_hh_veh.fillna(0.0, inplace=True)
        avg_hh_veh.replace(np.inf, 0.0, inplace=True)
        
        # Get the walk scores
        walk_scores = mc.fetchAccessScores(scen, "walk", p, "to", activity,
                                           index_cols, suffix=suffix,
                                           match_axis=var_axis,
                                           match_level=var_level,
                                           imped_tag=imped_tag_w)
        # Get the auto scores
        auto_scores = mc.fetchAccessScores(scen, "auto", p, "to", activity,
                                          [TAZ_ACCESS_KEY], match_level=TAZ_LEVEL,
                                          match_axis=mc_taz.TAZ)
        
        # Push scores to block level
        if scale == "block":
            auto_scores = mc.inheritAccessScore(auto_scores, mc_block.block_id)
            avg_hh_veh = mc.inheritAccessScore(avg_hh_veh, mc_block.block_id)
            share_Inc4 = mc.inheritAccessScore(share_Inc4, mc_block.block_id)
        
        # WAR
        war = walk_scores/auto_scores
        war.fillna(0.0, inplace=True)
        tar.replace(np.inf, 0.0, inplace=True)

        # Walk time to transit
        nonprem =  walk_access["non_prem"][scale.lower()]

        # Create the model dictionary
        model_dict = {
            dim_name: {
                "values": [
                    avg_hh_veh,
                    share_Inc4,
                    war,
                    nonprem
                    ],
                "coef": [
                    coef_dict[p].get("AvgHHVeh", 0.0),
                    coef_dict[p].get("HighIncHHs", 0.0),
                    coef_dict[p].get("WAR", 0.0),
                    coef_dict[p].get("Nonprem", 0.0),
                    ]
                }
            }
        intercept = coef_dict[p].get("Intercept", 0.0)
        crit = {"Purpose": p, "End": end, "Mode": "walk"}
        mc.modeChoiceApply(array, intercept, model_dict, this_mode,
                           complement, MODE_DICT, crit, logger=logger)

# %% ATTRACTIONS: WAT VS. DAT
# Variables:
#  - Share of zero-vehicle households in WAT access shed
#      - WAT access from zero-vehicle HHs
#      - WAT access from all HHs
#  - Regional centrality (auto access to jobs [nat. log])
#  - Transit access (WAT) to low income households (nat. log)
#  - Walk time to transit
#      - Premium
print("WAT / DAT (attractions)")
end = "A"
this_mode = "WAT"
complement = "DAT"
logger.info(
    f"Estimated mode: {this_mode}\n\tComplement mode: {complement}\n\tEnd: {end}")

coef_dict = {
    "HBW": {
        "Intercept": -0.6044,
        "Veh0": 6.3762,
        "LowIncHHs": 0.5406,
        "Prem": -0.6801,
        "JobsAccess": -0.4148
        },
    "HBO": {
        "Intercept": 16.5197,
        "Veh0": 9.2434,
        "LowIncHHs": 0.6802,
        "Prem": -1.0603,
        "JobsAccess": -1.7771
        },
    "HBSch": {
        "Intercept": 4.3449,
        "Veh0": 24.4036,
        "Prem": -0.8100,
        "JobsAccess": -0.5856
        },
    "NHB": {
        "Intercept": 1.05828 # This is an intercept-only model
        }
    }

for p in PURPOSES:
    logger.info(f"-- Purpose: {p}")
    # Get the accessibility scores that correspond to each purpose
    activity = PURP_ACTIVITIES[p]
    
    for scale in SCALES:
        logger.info(f"-- -- Scale: {scale}")
        refs = getScaleRefs(scale)
        index_cols, suffix, var_axis, var_level, dim_name,\
            array, imped_tag = refs
        if imped_tag:
            imped_tag_w = imped_tag.replace("Bike", "Walk")
        else:
            imped_tag_w = ""
        
        # Get zero vehicle HHs
        wat_0veh = mc.fetchAccessScores(scen, "transit", p, "from", "Veh0",
                                       [TAZ_ACCESS_KEY], match_level=TAZ_LEVEL,
                                       match_axis=mc_taz.TAZ)
        wat_0veh.columns = ["TotalHH"]
        # Get Low income HHs
        wat_Inc1 = mc.fetchAccessScores(scen, "transit", p, "from", "Income1",
                                       [TAZ_ACCESS_KEY], match_level=TAZ_LEVEL,
                                       match_axis=mc_taz.TAZ)
        wat_Inc1.columns = ["TotalHH"]
        wat_Inc1 = np.log(wat_Inc1 + 1)
        # Get all HHs
        wat_hh = mc.fetchAccessScores(scen, "transit", p, "from", "TotalHH",
                                     [TAZ_ACCESS_KEY], match_level=TAZ_LEVEL,
                                     match_axis=mc_taz.TAZ)
        # Get auto access to jobs
        auto_jobs = mc.fetchAccessScores(scen, "auto", "HBW", "to",
                                         "Total Emp", [TAZ_ACCESS_KEY],
                                         match_axis=mc_taz.TAZ, match_level=TAZ_LEVEL)
        auto_jobs = np.log(auto_jobs + 1)

        # Share zero vehicles
        share_0veh = wat_0veh/wat_hh
        share_0veh.fillna(0.0, inplace=True)
        share_0veh.replace(np.inf, 0.0, inplace=True)
        
        # Push scores to block level
        if scale == "block":
            share_0veh = mc.inheritAccessScore(share_0veh, mc_block.block_id)
            wat_Inc1 = mc.inheritAccessScore(wat_Inc1, mc_block.block_id)
            auto_jobs = mc.inheritAccessScore(auto_jobs, mc_block.block_id)
            
        # Walk times
        prem =  walk_access["prem"][scale.lower()]

        # Create the model dictionary
        model_dict = {
            dim_name: {
                "values": [
                    share_0veh,
                    wat_Inc1,
                    prem,
                    auto_jobs
                    ],
                "coef": [
                    coef_dict[p].get("Veh0", 0.0),
                    coef_dict[p].get("LowIncHHs", 0.0),
                    coef_dict[p].get("Prem", 0.0),
                    coef_dict[p].get("JobsAccess", 0.0)
                    ]
                }
            }
        intercept = coef_dict[p].get("Intercept", 0.0)
        crit = {"Purpose": p, "End": end, "Mode": "walk"}
        mc.modeChoiceApply(array, intercept, model_dict, this_mode,
                           complement, MODE_DICT, crit, logger=logger)

# %% ATTRACTIONS: WALK VS. BIKE
# Variables:
#  - Walk-bike access to jobs ratio
#      - Walk access to jobs
#      - Bike access to jobs
#  - Share of HHs in bike shed that are high income (Income4)
print("Walk / Bike (attractions)")
this_mode = "walk"
complement = "bike"
logger.info(
    f"Estimated mode: {this_mode}\n\tComplement mode: {complement}\n\tEnd: {end}")

coef_dict = {
    "HBW": {
        "Intercept": 1.3965,
        "WBR": 1.1169,
        "HighIncHHs": -3.6308
        },
    "HBO": {
        "Intercept": 2.0017,
        "WBR": 2.7876,
        "HighIncHHs": -1.4972
        },
    "HBSch": {
        "Intercept": 2.5183,
        "WBR": 2.9866,
        "HighIncHHs": -2.9767
        },
    "NHB": {
        "Intercept": 1.5407,
        "WBR": 6.7218
        }
    }

for p in PURPOSES:
    logger.info(f"-- Purpose: {p}")
    # Get the accessibility scores that correspond to each purpose
    activity = PURP_ACTIVITIES[p]
    
    for scale in SCALES:
        logger.info(f"-- -- Scale: {scale}")
        refs = getScaleRefs(scale)
        index_cols, suffix, var_axis, var_level, dim_name,\
            array, imped_tag = refs
        if imped_tag:
            imped_tag_w = imped_tag.replace("Bike", "Walk")
        else:
            imped_tag_w = ""
            
        # Get walk scores
        walk_scores = mc.fetchAccessScores(scen, "walk", p, "to", activity,
                                           index_cols, suffix=suffix,
                                           match_axis=var_axis,
                                           match_level=var_level,
                                           imped_tag=imped_tag_w)
        # Get bike scores
        bike_scores = mc.fetchAccessScores(scen, "bike", p, "to", activity,
                                           index_cols, suffix=suffix,
                                           match_axis=var_axis,
                                           match_level=var_level,
                                           imped_tag=imped_tag)
        # Get bike access to all hhs
        bike_hh = mc.fetchAccessScores(scen, "bike", p, "from", "TotalHH",
                                       index_cols, suffix=suffix,
                                       match_axis=var_axis,
                                       match_level=var_level,
                                       imped_tag=imped_tag)
        # Get bike access to high income hhs
        bike_Inc4 = mc.fetchAccessScores(scen, "bike", p, "from", "Income4",
                                         index_cols, suffix=suffix,
                                         match_axis=var_axis,
                                         match_level=var_level,
                                         imped_tag=imped_tag)
        bike_Inc4.columns = ["TotalHH"]
        
        # Ratios
        wbr = walk_scores/bike_scores
        wbr.fillna(0.0, inplace=True)
        wbr.replace(np.inf, 1.0, inplace=True)
        
        share_Inc4 = bike_Inc4/bike_hh
        share_Inc4.fillna(0.0, inplace=True)
        share_Inc4.replace(np.inf, 0.0, inplace=True)
        
        # Create the model dictionary
        model_dict = {
            dim_name: {
                "values": [
                    wbr,
                    share_Inc4,
                    ],
                "coef": [
                    coef_dict[p].get("WBR", 0.0),
                    coef_dict[p].get("HighIncHHs", 0.0)
                    ]
                }
            }
        intercept = coef_dict[p].get("Intercept", 0.0)
        crit = {"Purpose": p, "End": end, "Mode": "walk"}
        mc.modeChoiceApply(array, intercept, model_dict, this_mode,
                           complement, MODE_DICT, crit, logger=logger)

# %% NON-HOME-BASED PRODUCTIONS: SUMMARIZE TRIP ATTRACTIONS BY MODE
# Using the mode choice estimates calculated for trip attractions above
#  estimate total trip attractions by mode. To do so, query trip gen
#  attractions by zone and apply the mode choice estimates.
# Write current results to disk. This is everything except NHB productions.
print ("writing mode choice results (pre-NHB)")
mc_taz_disk.data[:] = mc_taz.data
mc_block_disk.data[:] = mc_block.data

print ("writing trips by mode results (pre-NHB)")
trips_taz_disk.data[:] = trips_taz_disk.data[:] * mc_taz.data
trips_block_disk.data[:] = trips_block_disk.data[:] * mc_block.data

# Summarize attractions by zone and mode
attr_sum_taz = trips_taz_disk.take(
    squeeze=True, End="A").sum(["TAZ", "Mode"])
attr_sum_block = trips_block_disk.take(
    squeeze=True, End="A").sum(["block_id", "Mode"])

#Log
logger.info(
    f"Interim trip sums (broadcast into {len(MODES)} modal dimensions and" +
    "factored based on mode choice model results - NHB Ps TBD)")
mc.mcInfo(logger, trips_taz_disk, trips_block_disk, mc_taz_disk, mc_block_disk)

# %% NON-HOME-BASED PRODUCTIONS: GET ATTRACTION MODE SHARES BY ZONE
print("Summarizing attraction-end mode shares")
total_attr_taz = attr_sum_taz.sum("TAZ")
total_attr_block = attr_sum_block.sum("block_id")

# TAZ Shares
attr_sum_taz.data /= lba.broadcast1dByAxis(attr_sum_taz, "TAZ",
                                           total_attr_taz.data).data
attr_sum_taz.data = np.nan_to_num(attr_sum_taz.data, nan=0.0)

# Block shares
attr_sum_block.data /= lba.broadcast1dByAxis(attr_sum_block, "block_id",
                                             total_attr_block.data).data
attr_sum_block.data = np.nan_to_num(attr_sum_block.data, nan=0.0)

# %% NON-HOME-BASED PRODUCTIONS: NON-MOTORIZED VS. MOTORIZED 
# Variables
#  - Bike-auto access ratio (ln(bike_scores + 1)/ln(auto_scores + 1))
#      - Bike access to jobs
#      - Auto access to jobs
#  - Previous mode of travel (apply estimated attraction shares)
#      - Passenger
#      - DAT
#      - WAT
#      - Bike
#      - Walk
print("Nonmotorized / motorized (NHB)")
end = "P"
this_mode = "non-motorized"
complement = "motorized"
logger.info(
    f"Estimated mode: {this_mode}\n\tComplement mode: {complement}\n\tEnd: {end}")

coef_dict = {
        "Intercept": -9.3625,
        "BAR": 8.8013,
        "Pax": 0.3952,
        "DAT": 1.4470,
        "WAT": 1.9044,
        "Bike": 4.0819,
        "Walk": 3.0163
    }

p = "NHB"
activity = PURP_ACTIVITIES[p]
logger.info(f"-- Purpose: {p}")

for scale in SCALES:
    logger.info(f"-- -- Scale: {scale}")
    refs = getScaleRefs(scale)
    index_cols, suffix, var_axis, var_level, dim_name,\
        array, imped_tag = refs
    if imped_tag:
        imped_tag_w = imped_tag.replace("Bike", "Walk")
    else:
        imped_tag_w = ""
    
    # Get bike scores
    bike_scores = mc.fetchAccessScores(scen, "bike", p, "to", activity,
                                       index_cols, suffix=suffix,
                                       match_axis=var_axis,
                                       match_level=var_level,
                                       imped_tag=imped_tag)
    
    auto_scores = mc.fetchAccessScores(scen, "auto", p, "to", activity,
                                       [TAZ_ACCESS_KEY], match_level=TAZ_LEVEL,
                                       match_axis=mc_taz.TAZ)
    
    # Push auto scores to block level
    if scale == "block":
        auto_scores = mc.inheritAccessScore(auto_scores, mc_block.block_id)
        attr_sum = attr_sum_block
    else:
        attr_sum = attr_sum_taz
    
    # Calculate BAR
    auto_scores = np.log(auto_scores + 1)
    bike_scores = np.log(bike_scores + 1)
    bar = bike_scores/auto_scores
    bar.fillna(0.0, inplace=True)
    bar.replace(np.inf, 0.0, inplace=True)

    # Attraction shares
    pax = attr_sum.take(Mode="passenger", squeeze=True).data
    dat = attr_sum.take(Mode="DAT", squeeze=True).data
    wat = attr_sum.take(Mode="WAT", squeeze=True).data
    bike = attr_sum.take(Mode="bike", squeeze=True).data
    walk = attr_sum.take(Mode="walk", squeeze=True).data

    # Create the model dictionary
    model_dict = {
        dim_name: {
            "values": [
                bar,
                pax,
                dat,
                wat,
                bike,
                walk
                ],
            "coef": [
                coef_dict.get("BAR", 0.0),
                coef_dict.get("Pax", 0.0),
                coef_dict.get("DAT", 0.0),
                coef_dict.get("WAT", 0.0),
                coef_dict.get("Bike", 0.0),
                coef_dict.get("Walk", 0.0)
                ]
            }
        }
    intercept = coef_dict.get("Intercept", 0.0)
    crit = {"Purpose": p, "End": end, "Mode": "walk"}
    mc.modeChoiceApply(array, intercept, model_dict, this_mode, complement,
                       MODE_DICT, crit, logger=logger)

#%% NON-HOME-BASED PRODUCTIONS: AUTO VS. TRANSIT
# Variables
#  - Transit-auto access ratio
#      - WAT access to jobs
#      - Auto access to jobs
#  - Walk time to transit
#      - Premium
#      - Nonpremium
#  - Previous mode of travel (apply estimated attraction shares)
#      - Passenger
#      - DAT
#      - WAT
#      - Bike
#      - Walk
print("Auto / transit (NHB)")
end = "P"
this_mode = "auto"
complement = "transit"
logger.info(
    f"Estimated mode: {this_mode}\n\tComplement mode: {complement}\n\tEnd: {end}")

coef_dict = {
        "Intercept": 5.4512,
        "TAR": -0.9816,
        "Prem": -1.2370,
        "Nonprem": -0.6065,
        "Pax": -0.4555,
        "DAT": -4.4251,
        "WAT": -5.3328,
        "Bike": -2.8032,
        "Walk": -3.4135
    }

p = "NHB"
activity = PURP_ACTIVITIES[p]
logger.info(f"-- Purpose: {p}")

for scale in SCALES:
    logger.info(f"-- -- Scale: {scale}")
    refs = getScaleRefs(scale)
    index_cols, suffix, var_axis, var_level, dim_name,\
        array, imped_tag = refs
    if imped_tag:
        imped_tag_w = imped_tag.replace("Bike", "Walk")
    else:
        imped_tag_w = ""
    
    # Get transit scores
    wat_scores = mc.fetchAccessScores(scen, "transit", p, "to", activity,
                                      [TAZ_ACCESS_KEY], match_level=TAZ_LEVEL,
                                      match_axis=mc_taz.TAZ)
    # Auto scores
    auto_scores = mc.fetchAccessScores(scen, "auto", p, "to", activity,
                                      [TAZ_ACCESS_KEY], match_level=TAZ_LEVEL,
                                      match_axis=mc_taz.TAZ)
    # Calculate TAR
    tar = wat_scores/auto_scores
    tar.fillna(0.0, inplace=True)
    tar.replace(np.inf, 0.0, inplace=True)

    # Push tar scores to block level
    if scale == "block":
        tar = mc.inheritAccessScore(tar, mc_block.block_id)
        attr_sum = attr_sum_block
    else:
        attr_sum = attr_sum_taz

    #Walk times
    prem =  walk_access["prem"][scale.lower()]
    nonprem = walk_access["non_prem"][scale.lower()]

    # Attraction shares
    pax = attr_sum.take(Mode="passenger", squeeze=True).data
    dat = attr_sum.take(Mode="DAT", squeeze=True).data
    wat = attr_sum.take(Mode="WAT", squeeze=True).data
    bike = attr_sum.take(Mode="bike", squeeze=True).data
    walk = attr_sum.take(Mode="walk", squeeze=True).data

    # Create the model dictionary
    model_dict = {
        dim_name: {
            "values": [
                tar,
                prem,
                nonprem,
                pax,
                dat,
                wat,
                bike,
                walk
                ],
            "coef": [
                coef_dict.get("TAR", 0.0),
                coef_dict.get("Prem", 0.0),
                coef_dict.get("Nonprem", 0.0),
                coef_dict.get("Pax", 0.0),
                coef_dict.get("DAT", 0.0),
                coef_dict.get("WAT", 0.0),
                coef_dict.get("Bike", 0.0),
                coef_dict.get("Walk", 0.0)
                ]
            }
        }
    intercept = coef_dict.get("Intercept", 0.0)
    crit = {"Purpose": p, "End": end, "Mode": "walk"}
    mc.modeChoiceApply(array, intercept, model_dict, this_mode, complement,
                       MODE_DICT, crit, logger=logger)

#%% NON-HOME-BASED PRODUCTIONS: DRIVER VS PASSENGER
# Variables
#  - Previous mode of travel (apply estimated attraction shares)
#      - Passenger
#      - DAT
#      - WAT
#      - Bike
#      - Walk
print("Driver / passenger (NHB)")
end = "P"
this_mode = "driver"
complement = "passenger"
logger.info(
    f"Estimated mode: {this_mode}\n\tComplement mode: {complement}\n\tEnd: {end}")

coef_dict = {
        "Intercept": 3.5675,
        "Pax": -7.0568,
        "DAT": -3.3809,
        "WAT": -4.9256,
        "Bike": -3.9242,
        "Walk": -4.3180
    }

p = "NHB"
activity = PURP_ACTIVITIES[p]
logger.info(f"-- Purpose: {p}")

for scale in SCALES:
    logger.info(f"-- -- Scale: {scale}")
    refs = getScaleRefs(scale)
    index_cols, suffix, var_axis, var_level, dim_name,\
        array, imped_tag = refs
    if imped_tag:
        imped_tag_w = imped_tag.replace("Bike", "Walk")
    else:
        imped_tag_w = ""

    if scale == "block":
        attr_sum = attr_sum_block
    else:
        attr_sum = attr_sum_taz

    # Attraction shares
    pax = attr_sum.take(Mode="passenger", squeeze=True).data
    dat = attr_sum.take(Mode="DAT", squeeze=True).data
    wat = attr_sum.take(Mode="WAT", squeeze=True).data
    bike = attr_sum.take(Mode="bike", squeeze=True).data
    walk = attr_sum.take(Mode="walk", squeeze=True).data

    # Create the model dictionary
    model_dict = {
        dim_name: {
            "values": [
                pax,
                dat,
                wat,
                bike,
                walk
                ],
            "coef": [
                coef_dict.get("Pax", 0.0),
                coef_dict.get("DAT", 0.0),
                coef_dict.get("WAT", 0.0),
                coef_dict.get("Bike", 0.0),
                coef_dict.get("Walk", 0.0)
                ]
            }
        }
    intercept = coef_dict.get("Intercept", 0.0)
    crit = {"Purpose": p, "End": end, "Mode": "walk"}
    mc.modeChoiceApply(array, intercept, model_dict, this_mode, complement,
                       MODE_DICT, crit, logger=logger)

#%% NON-HOME-BASED PRODUCTIONS: WAT VS. DAT
# Variables
#  - Transit-walk/drive access ratio
#      - WAT access to jobs
#      - DAT access to jobs
#  - Walk time to transit
#      - Premium
#  - Previous mode of travel (apply estimated attraction shares)
#      - Passenger
#      - DAT
#      - WAT
#      - Bike
#      - Walk
print("WAT / DAT (NHB)")
end = "P"
this_mode = "WAT"
complement = "DAT"
logger.info(
    f"Estimated mode: {this_mode}\n\tComplement mode: {complement}\n\tEnd: {end}")

coef_dict = {
        "Intercept": -1.2191,
        "WDR": 0.9644,
        "Prem": 1.2796,
        "Pax": 1.0357,
        "WAT": 3.5506,
        "Nonmotor": 3.1050
    }

p = "NHB"
activity = PURP_ACTIVITIES[p]
logger.info(f"-- Purpose: {p}")

for scale in SCALES:
    logger.info(f"-- -- Scale: {scale}")
    refs = getScaleRefs(scale)
    index_cols, suffix, var_axis, var_level, dim_name,\
        array, imped_tag = refs
    if imped_tag:
        imped_tag_w = imped_tag.replace("Bike", "Walk")
    else:
        imped_tag_w = ""
    
    # Get the transit scores
    wat_scores = mc.fetchAccessScores(scen, "transit", p, "to", activity,
                                      [TAZ_ACCESS_KEY], match_level=TAZ_LEVEL,
                                      match_axis=mc_taz.TAZ)
    max_scores = mc.fetchAccessScores(scen, "transit_da", p, "to", activity,
                                      [TAZ_ACCESS_KEY], match_level=TAZ_LEVEL,
                                      match_axis=mc_taz.TAZ)
    max_scores.replace(0.0, 1.0, inplace=True)
    
    # Calcualte WDR
    wdr = wat_scores/max_scores
    wdr.clip(0, 100, inplace=True)
    
    # Push WDR to block level
    if scale == "block":
        wdr = mc.inheritAccessScore(wdr, mc_block.block_id)
        attr_sum = attr_sum_block
    else:
        attr_sum = attr_sum_taz
    
    #Walk times
    prem =  walk_access["prem"][scale.lower()]
    
    # Attraction shares
    pax = attr_sum.take(Mode="passenger", squeeze=True).data
    dat = attr_sum.take(Mode="DAT", squeeze=True).data
    wat = attr_sum.take(Mode="WAT", squeeze=True).data
    bike = attr_sum.take(Mode="bike", squeeze=True).data
    walk = attr_sum.take(Mode="walk", squeeze=True).data
    nonmotor = bike + walk

    # Create the model dictionary
    model_dict = {
        dim_name: {
            "values": [
                wdr,
                prem,
                pax,
                dat,
                wat,
                nonmotor
                ],
            "coef": [
                coef_dict.get("WDR", 0.0),
                coef_dict.get("Prem", 0.0),
                coef_dict.get("Pax", 0.0),
                coef_dict.get("DAT", 0.0),
                coef_dict.get("WAT", 0.0),
                coef_dict.get("Nonmotor", 0.0),
                ]
            }
        }
    intercept = coef_dict.get("Intercept", 0.0)
    crit = {"Purpose": p, "End": end, "Mode": "walk"}
    mc.modeChoiceApply(array, intercept, model_dict, this_mode, complement,
                       MODE_DICT, crit, logger=logger)

#%% NON-HOME-BASED PRODUCTIONS: WALK VS. BIKE
# Variables
#  - Walk/bike access ratio
#      - walk access to jobs
#      - bike access to jobs
#  - Previous mode of travel (apply estimated attraction shares)
#      - Bike
#      - Walk
print("Walk / Bike (NHB)")
end = "P"
this_mode = "walk"
complement = "bike"
logger.info(
    f"Estimated mode: {this_mode}\n\tComplement mode: {complement}\n\tEnd: {end}")

coef_dict = {
        "Intercept": 2.8420,
        "WBR": 5.4731,
        "Bike": -5.0772,
        "Walk": 0.6826
    }

p = "NHB"
activity = PURP_ACTIVITIES[p]
logger.info(f"-- Purpose: {p}")

for scale in SCALES:
    logger.info(f"-- -- Scale: {scale}")
    refs = getScaleRefs(scale)
    index_cols, suffix, var_axis, var_level, dim_name,\
        array, imped_tag = refs
    if imped_tag:
        imped_tag_w = imped_tag.replace("Bike", "Walk")
    else:
        imped_tag_w = ""
    
    # Get walk scores
    walk_scores = mc.fetchAccessScores(scen, "walk", p, "to", activity,
                                       index_cols, suffix=suffix,
                                       match_axis=var_axis,
                                       match_level=var_level,
                                       imped_tag=imped_tag_w)
    # Get bike scores
    bike_scores = mc.fetchAccessScores(scen, "bike", p, "to", activity,
                                       index_cols, suffix=suffix,
                                       match_axis=var_axis,
                                       match_level=var_level,
                                       imped_tag=imped_tag)
    # Ratios
    wbr = walk_scores/bike_scores
    wbr.fillna(0.0, inplace=True)
    wbr.replace(np.inf, 1.0, inplace=True)
    
    # Attraction shares
    if scale == "block":
        attr_sum = attr_sum_block
    else:
        attr_sum = attr_sum_taz
    bike = attr_sum.take(Mode="bike", squeeze=True).data
    walk = attr_sum.take(Mode="walk", squeeze=True).data

    # Create the model dictionary
    model_dict = {
        dim_name: {
            "values": [
                wbr,
                walk,
                bike
                ],
            "coef": [
                coef_dict.get("WBR", 0.0),
                coef_dict.get("Walk", 0.0),
                coef_dict.get("Bike", 0.0),
                ]
            }
        }
    intercept = coef_dict.get("Intercept", 0.0)
    crit = {"Purpose": p, "End": end, "Mode": "walk"}
    mc.modeChoiceApply(array, intercept, model_dict, this_mode, complement,
                       MODE_DICT, crit, logger=logger)

#%% NON-HOME-BASED PRODUCTIONS: WRITE OUTPUT
# Save the NHB P mode choices to disk and apply to trips by mode
# Iterate to write outputs by mode for performance
crit = {"Purpose": "NHB", "End": "P"}

print ("writing TAZ mode choice results (NHB)")
for mode in MODES:
    print ("..", mode)
    crit["Mode"] = mode
    mc_taz_disk.put(
        mc_taz.take(squeeze=True, **crit).data,
        **crit)
    trips_taz_disk.put(
        trips_taz_disk.take(squeeze=True, **crit).data *
        mc_taz.take(squeeze=True, **crit).data,
        **crit)

print ("writing block mode choice results (NHB)")
for mode in MODES:
    print ("..", mode)
    crit["Mode"] = mode
    mc_block_disk.put(
        mc_block.take(squeeze=True, **crit).data,
        **crit)
    trips_block_disk.put(
        trips_block_disk.take(squeeze=True, **crit).data *
        mc_block.take(squeeze=True, **crit).data,
        **crit)

#Log
logger.info(
    f"Final trip sums (broadcast into {len(MODES)} modal dimensions and" +
    "factored based on mode choice model results - NHB Ps TBD)")
mc.mcInfo(logger, trips_taz_disk, trips_block_disk, mc_taz_disk, mc_block_disk)

# %% REPORT
out_csv = r"scen\{}\trips_by_mode_predist.csv".format(scen)
mc.reportTripsByMode(trips_taz_disk, trips_block_disk, out_csv)